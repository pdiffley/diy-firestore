{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    h2: \"h2\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Bonus Features and Configurability\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"One of the nice things about building your own database is that you can make it\\ndo whatever you want! So far in this series, we have been focussed on\\nreplicating the features of Firestore. Now we will take a high level look at\\nsome additional features we might want to add.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Opt in queries on simple fields\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We saw earlier in the Simple Query and Simple Query Subscription sections the\\nprocessing overhead that comes with supporting simple queries on all document fields\\nby default. Having fields be automatically queryable is convenient when you are just\\nstarting a project and want to mimimize any required configuration,\\nbut for a mature project, specifying which fields you want to be able to query\\nis not a very high burden.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We could provide the option to have simple queries be\\nopt in on a field, document, or collection level. This would significantly\\nreduce the cost of writing new documents to the database. Since we would be\\nrunning this database on our own infrastructure, reducing the write overhead\\nwould have a direct impact on our cloud costs.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Allow more complex compound queries\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This one comes with some caveats. Firestore only allows us to have inequality\\noperators on one field in a composite query. This pretty much guarantees that we\\nwill not write an inefficient query. Once you start allowing inequality\\noperators on more than one field, the effectiveness of the B-Tree index for that\\nquery starts to go down significantly. Since we would be responsible for the database's overall compute cost\\nrather than paying per document read and write, we could allow these potentially less efficient queries.\\nThe responsibility would be on us to not create a terribly inefficient query.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Configurable TTL for client subscriptions\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In Firestore, if a client has been disconnected for more than about 30 minutes,\\nany subscriptions made by the client expire and will have to be fully reloaded\\nwhen the client reconnects. This is generally a good thing as it prevents you\\nfrom performing upkeep on old subscriptions from disconnected clients that will\\nnever be checked again, but the TTL that you would want to have on a subscription can vary\\nsignificantly with what the user is subscribing to.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For example, you may have a\\nsubscription to a high touch document that you only want to be active while the\\nclient is connected and receiving updates. In this case the cost of\\nreloading the entire subscription (one document) is low, and the cost of\\nmaintaining the subscription (a frequent additional write) is high.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"A very different situation would be a messaging app. For a messaging app,\\nyou would ideally like to subscribe to a user's\\nmessages once and never have to reload the entire message history again.\\nReloading a users entire message history is expensive, but just\\nretrieving the messages they have received since they last connected is\\nrelatively cheap. In this case you would want to set a long TTL (eg. weeks), so\\nthat full refreshes are rare.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Firestore likely doesn't allow you to adjust the TTL for a subscription because\\nusers are charged a fixed price per read and write. Increasing the TTL on a\\nsubscription would increase the internal cost of those operations. Since,\\nwe are running this database on our own infrastructure, there is nothing\\nstopping us from setting TTL's that makes the most sense for our application and\\nsubscriptions (I am still annoyed by how much time I could have saved in a\\nprevious project if Firestore provided this feature out of the box).\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Protobuf-like ability to rename collections and field names\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Being schemaless is one of Firestore's selling points, but there are often times\\nwhere that can slow down development. One way this comes up is in choosing name\\nfor fields and collections. When you are starting a project that needs to\\niterate rapidly, you likely don't want to spend lots of time carefully choosing\\nnames for your fields, and you also don't have the full context of what other\\nfields and collections might exist in the future. This can lead to a situation\\nwhere after a few months of development naming choices that made sense early on\\nbecome quite confusing. Because collection and field names are stored explicitly as strings within\\nFirestore and referenced explicitly in client code, migrating these names\\nwithout causing interuptions is difficult.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It would be great to be able to provide a client side config that would\\ntranslate between an internal name that is stored in the firestore and a name\\nthat is used in your client side code (much like protobuf). Then you could name\\nyour fields whatever you felt like in the moment, have those field names be\\ngiven a constant compact representation, and change the client side name\\nwhenever you want.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Provide transparent support for large blob storage\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"One of the annoying things about working with photos, videos, and other large\\nfiles types is that you can't (or at least shouldn't) store them directly in\\nyour database. The standard solution is to store the large file in networked\\nstorage and save the file's path in your database. This works, but adds\\nadditional hassle when working with these files since you have to first retrieve\\nthe file path from the database, then separately load the file from\\nstorage, and then do the reverse if you are editing the file.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We are already putting a server in front of our database, so there is not much\\nstopping us from providing a extra \\\"large_blob\\\" data type that will\\ntransparently do this file management for us. Behind the scenes we would manage\\nwriting the blob in file storage, and writing the file id in the database. From\\nthe user's perspective you would be allowed to write arbitrarily sized blobs\\ndirectly to the database, without encountering the performance issues this would\\nnormally incur.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"title":"Bonus Features and Configurability","index":15,"previousPost":{"title":"Update Delivery","index":14,"slug":"client-connection-server"},"nextPost":null},"__N_SSG":true}