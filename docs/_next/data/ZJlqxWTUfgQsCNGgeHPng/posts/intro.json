{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\n/*image of wrench bucket -> fire*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    strong: \"strong\",\n    em: \"em\",\n    h2: \"h2\",\n    h3: \"h3\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Getting Started\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: _jsx(_components.em, {\n          children: \"How hard could it be?\"\n        })\n      })\n    }), \"\\n\", \"\\n\", _jsx(_components.p, {\n      children: \"Firestore is pretty cool. It is a NoSQL document database that lets you store\\narbitrary documents in hierarchical collections, but it also lets you perform\\nqueries and transactions similar to those you can make with a SQL database. On\\ntop of that, Firestore allows frontend clients to connect directly to the\\ndatabase and listen for changes that affect their queries, removing the need for\\nthe user to implement stateful websockets or poll their servers for updates. In\\nthis regard Firestore acts not only as a database, but also as a full fledged\\nsystem for managing data synchronization between your frontend and backend.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In this article we will take a look at how we could implement many of the\\nfeatures that Firestore provides using standard open source and cloud\\ntechnologies.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But first,\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Why would we do this?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It's a fair question. Firestore is flush with features, so why would we go\\nthrough the effort of implementing a system that does pretty much the same\\nthing?\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"It's fun!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Just had to get this out of the way. I am mostly just writing this for fun.\\nFirestore is a pretty cool system to investigate, so I hope you enjoy reading\\nabout how I go about implementing it!\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"You're not on Google Cloud Platform\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Firestore is a GCP product and does not have a direct equivalent in other cloud\\nproviders. If all of your apps and services are based in AWS for example, you\\nmight not be able to readily use technologies in GCP. Or maybe your division\\nbuilt multiple frontend apps around Firebase, then your company made the\\nunilateral decision to move to AWS, and now you are stuck figuring out what to\\ndo.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"You need more configurability\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Firestore is a generic product and does not provide many options for configuration.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"All database resources are managed for you and you pay per read and write. When you are starting a project,\\nit can be convenient to only pay for your individual reads and writes, but it limits the amount of\\nconfigurability you can have. A cost model where you pay for the underlying\\ninfrastructure supporting your database rather than paying per read and write removes these limitations.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"At the end of this series, I will show some examples\\nof how we could customize our database to suit our needs in a way that Firestore might not.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Your cloud costs are too high\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Firestore is designed to be highly scalable and have a low barrier to entry, but\\nit is also quite expensive. This likely doesn't matter when you are just\\nstarting a company and want to get up and running quickly, but as your traffic\\ngrows, Firestore's high price per read and write could become a problem.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Over the course of this series, we will see how Firestore's default features incur a lot\\nof overhead whether you are using them or not. Firestore lets you turn some of\\nthese features off, but many of them are on no matter what. Running a customized\\nversion of Firestore would give you the transparency needed to understand what\\noperations are expensive and allow you to turn off expensive features that you\\ndon't need.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"#Goals\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The purpose of this article is to demonstrate how we could implement a data\\nmanagement system like Firestore using technologies that are either open source\\nor available with most cloud providers.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I will focus on designing this system so that we get our desired features with\\nacceptable time and space complexity, but I will not focus on optimizing our\\nsolution. Instead, I want to convey how we could overcome the key technical\\nhurdles that get in the way of making a database like Firestore, and to that\\nend, will opt for clarity over performance. Likewise, code samples I include\\nwill be correct, but won't be production ready. I will assume that all inputs\\nare validated and well formatted and the general approach to error handling\\nwill be to throw a runtime error. Let chaos reign!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I also want to note in advance that I do not have any inside knowledge of how\\nFirestore is implemented. This series is just me taking a stab at how I would\\nbuild a similar product.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Next up\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"With all that out of the way, let's define the scope of what we will be covering in this series.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"title":"Getting Started","index":1,"previousPost":null,"nextPost":{"title":"Defining Our Requirements","index":2,"slug":"defining-requirements"}},"__N_SSG":true}