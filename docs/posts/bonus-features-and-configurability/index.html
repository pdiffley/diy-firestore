<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>DIY Firestore: <!-- -->Bonus Features and Configurability</title><meta name="next-head-count" content="3"/><link rel="preload" href="/diy-firestore/_next/static/css/66a0bbf2b9cf8488.css" as="style"/><link rel="stylesheet" href="/diy-firestore/_next/static/css/66a0bbf2b9cf8488.css" data-n-g=""/><link rel="preload" href="/diy-firestore/_next/static/css/ada12569730546bb.css" as="style"/><link rel="stylesheet" href="/diy-firestore/_next/static/css/ada12569730546bb.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/diy-firestore/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/diy-firestore/_next/static/chunks/webpack-df07c8c7f42d9fe8.js" defer=""></script><script src="/diy-firestore/_next/static/chunks/framework-85abacfba991a725.js" defer=""></script><script src="/diy-firestore/_next/static/chunks/main-319ff90b30ad4d29.js" defer=""></script><script src="/diy-firestore/_next/static/chunks/pages/_app-4394fb9185eabbc7.js" defer=""></script><script src="/diy-firestore/_next/static/chunks/9f529197-49e08325ab61b49d.js" defer=""></script><script src="/diy-firestore/_next/static/chunks/97-3f87bb423d54673c.js" defer=""></script><script src="/diy-firestore/_next/static/chunks/pages/posts/%5B%5B...slug%5D%5D-0bd81a0611356f07.js" defer=""></script><script src="/diy-firestore/_next/static/Sa6E-7qGirZm202tYMp90/_buildManifest.js" defer=""></script><script src="/diy-firestore/_next/static/Sa6E-7qGirZm202tYMp90/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="post_content__PPM5L"><nav class="post_nav__Q8sPv"><div class="post_homeLink__F688Z"><a href="/diy-firestore/">DIY Firestore</a></div></nav><main id="main-content"><article class="post_article__Q7gsU"><h1>Bonus Features and Configurability</h1>
<p>One of the nice things about building your own database is that you can make it
do whatever you want! So far in this series, we have been focussed on
replicating the features of Firestore. Now we will take a high level look at
some additional features we might want to add.</p>
<h2>Opt in queries on simple fields</h2>
<p>We saw earlier in the Simple Query and Simple Query Subscription sections the
processing overhead that comes supporting simple queries on all document fields
by default. Having fields be automatically queriable is convenient when you are just
starting a project and want to mimimize any required configuration,
but for a mature project, specifying which fields you want to be able to query
is not a very high burden.</p>
<p>We could provide the option to have simple queries be
opt in on a field, document, or collection level. This would significantly
reduce the cost of writing new documents to the database. Since we would be
running this database on our own infrastructure, reducing the write overhead
would have a direct impact on our cloud costs.</p>
<h2>Allow more complex compound queries</h2>
<p>This one comes with some caveats. Firestore only allows us to have inequality
operators on one field in a composite query. This pretty much guarantees that we
will not write an inefficient query. Once you start allowing inequality
operators on more than one field, the effectiveness of the B-Tree index for that
query starts to go down significantly. Since we would be responsible for the database&#x27;s overall compute cost
rather than paying per document read and write, we could allow these potentially less efficient queries.
The responsibility would be on us to not create a terribly inefficient queries.</p>
<h2>Configurable TTL for client subscriptions</h2>
<p>In Firestore if a client has been disconnected for more than about 30 minutes,
any subscriptions made by the client expire and will have to be fully reloaded
when the client reconnects. This is generally a good thing as it prevents you
from performing upkeep on old subscriptions from disconnected clients that are
not going to be checked again, but the TTL that you would want to have on a subscription can vary
significantly with what the user is subscribing to. For example, you may have a
subscription to a high touch document that you only want to be active while the
client is connected and receiving updates. In this case the cost of
reloading the entire subscription (one document) is low, and the cost of
maintaining the subscription (a frequent additional write) is high.</p>
<p>A very different situation would be a messaging app (this one is from personal
experience). For a messaging app, you would ideally like to subscribe to a user&#x27;s
messages once and never have to reload the entire message history again.
Reloading a users entire message history is expensive, but just
retrieving the messages they have received since they last connected is
relatively cheap. In this case you would want to set a long TTL (eg. weeks), so
that full refreshes are rare.</p>
<p>Firestore likely doesn&#x27;t allow you to adjust the TTL for a subscription because
users are charged a fixed price per read and write. Increasing the TTL on a
subscription would increase the internal cost of those operations. Since,
we are running this database on our own infrastructure, there is nothing
stopping us from setting TTL&#x27;s that makes the most sense for our application and
subscriptions (I am still annoyed by how much time I could have saved in a
previous project if Firestore provided this feature out of the box).</p>
<h2>Protobuf-like ability to rename collections and field names</h2>
<p>Being schemaless is one of Firestore&#x27;s selling points, but there are often times
where that can slow down development. One way this comes up is in choosing name
for fields and collections. When you are starting a project that needs to
iterate rapidly, you likely don&#x27;t want to spend lots of time carefully choosing
names for your fields, but you also don&#x27;t have the full context of what other
fields and collections might exist in the future. This can lead to a situation
where after a few months of development, naming choices that made sense early on
become quite confusing. Because collection and field names are stored explicitly as strings within
Firestore and referenced explicitly in client code, migrating these names
without causing interuptions is difficult.</p>
<p>It would be great to be able to provide a client side config that would
translate between an internal name that is stored in the firestore and a name
that is used in your client side code (much like protobuf). Then you could name
your fields whatever you felt like in the moment, have those field names be
given a constant compact representation, and change the client side name
whenever you want.</p>
<h2>Provide transparent support for large blob storage</h2>
<p>One of the annoying things about working with photos, videos, and other large
files types is that you can&#x27;t (or at least shouldn&#x27;t) store them directly in
your database. The standard solution is to store the large file in networked
storage and save the path to the file in your database. This works, but adds
additional hassle when working with these files since you have to first retrieve
the file information from the database, then separately load the file from
storage, and then do the reverse if you are editing the file.</p>
<p>We are already putting a server in front of our database, so there is not much
stopping us from providing a extra &quot;large_blob&quot; data type that will
transparently do this file management for us. Behind the scenes we would manage
writing the blob in file storage, and writing the file id in the database. From
the user&#x27;s perspective you would be allowed to write arbitrarily sized blobs
directly to the database, without encountering the performance issues this would
normally incur.</p></article></main><footer class="post_footer__wtu2H"><div><a href="/diy-firestore/posts/client-connection-server/">‚Üê <!-- -->Update Delivery</a></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    h2: \"h2\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Bonus Features and Configurability\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"One of the nice things about building your own database is that you can make it\\ndo whatever you want! So far in this series, we have been focussed on\\nreplicating the features of Firestore. Now we will take a high level look at\\nsome additional features we might want to add.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Opt in queries on simple fields\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We saw earlier in the Simple Query and Simple Query Subscription sections the\\nprocessing overhead that comes supporting simple queries on all document fields\\nby default. Having fields be automatically queriable is convenient when you are just\\nstarting a project and want to mimimize any required configuration,\\nbut for a mature project, specifying which fields you want to be able to query\\nis not a very high burden.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We could provide the option to have simple queries be\\nopt in on a field, document, or collection level. This would significantly\\nreduce the cost of writing new documents to the database. Since we would be\\nrunning this database on our own infrastructure, reducing the write overhead\\nwould have a direct impact on our cloud costs.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Allow more complex compound queries\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This one comes with some caveats. Firestore only allows us to have inequality\\noperators on one field in a composite query. This pretty much guarantees that we\\nwill not write an inefficient query. Once you start allowing inequality\\noperators on more than one field, the effectiveness of the B-Tree index for that\\nquery starts to go down significantly. Since we would be responsible for the database's overall compute cost\\nrather than paying per document read and write, we could allow these potentially less efficient queries.\\nThe responsibility would be on us to not create a terribly inefficient queries.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Configurable TTL for client subscriptions\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In Firestore if a client has been disconnected for more than about 30 minutes,\\nany subscriptions made by the client expire and will have to be fully reloaded\\nwhen the client reconnects. This is generally a good thing as it prevents you\\nfrom performing upkeep on old subscriptions from disconnected clients that are\\nnot going to be checked again, but the TTL that you would want to have on a subscription can vary\\nsignificantly with what the user is subscribing to. For example, you may have a\\nsubscription to a high touch document that you only want to be active while the\\nclient is connected and receiving updates. In this case the cost of\\nreloading the entire subscription (one document) is low, and the cost of\\nmaintaining the subscription (a frequent additional write) is high.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"A very different situation would be a messaging app (this one is from personal\\nexperience). For a messaging app, you would ideally like to subscribe to a user's\\nmessages once and never have to reload the entire message history again.\\nReloading a users entire message history is expensive, but just\\nretrieving the messages they have received since they last connected is\\nrelatively cheap. In this case you would want to set a long TTL (eg. weeks), so\\nthat full refreshes are rare.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Firestore likely doesn't allow you to adjust the TTL for a subscription because\\nusers are charged a fixed price per read and write. Increasing the TTL on a\\nsubscription would increase the internal cost of those operations. Since,\\nwe are running this database on our own infrastructure, there is nothing\\nstopping us from setting TTL's that makes the most sense for our application and\\nsubscriptions (I am still annoyed by how much time I could have saved in a\\nprevious project if Firestore provided this feature out of the box).\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Protobuf-like ability to rename collections and field names\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Being schemaless is one of Firestore's selling points, but there are often times\\nwhere that can slow down development. One way this comes up is in choosing name\\nfor fields and collections. When you are starting a project that needs to\\niterate rapidly, you likely don't want to spend lots of time carefully choosing\\nnames for your fields, but you also don't have the full context of what other\\nfields and collections might exist in the future. This can lead to a situation\\nwhere after a few months of development, naming choices that made sense early on\\nbecome quite confusing. Because collection and field names are stored explicitly as strings within\\nFirestore and referenced explicitly in client code, migrating these names\\nwithout causing interuptions is difficult.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It would be great to be able to provide a client side config that would\\ntranslate between an internal name that is stored in the firestore and a name\\nthat is used in your client side code (much like protobuf). Then you could name\\nyour fields whatever you felt like in the moment, have those field names be\\ngiven a constant compact representation, and change the client side name\\nwhenever you want.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Provide transparent support for large blob storage\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"One of the annoying things about working with photos, videos, and other large\\nfiles types is that you can't (or at least shouldn't) store them directly in\\nyour database. The standard solution is to store the large file in networked\\nstorage and save the path to the file in your database. This works, but adds\\nadditional hassle when working with these files since you have to first retrieve\\nthe file information from the database, then separately load the file from\\nstorage, and then do the reverse if you are editing the file.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We are already putting a server in front of our database, so there is not much\\nstopping us from providing a extra \\\"large_blob\\\" data type that will\\ntransparently do this file management for us. Behind the scenes we would manage\\nwriting the blob in file storage, and writing the file id in the database. From\\nthe user's perspective you would be allowed to write arbitrarily sized blobs\\ndirectly to the database, without encountering the performance issues this would\\nnormally incur.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"title":"Bonus Features and Configurability","index":15,"previousPost":{"title":"Update Delivery","index":14,"slug":"client-connection-server"},"nextPost":null},"__N_SSG":true},"page":"/posts/[[...slug]]","query":{"slug":["bonus-features-and-configurability"]},"buildId":"Sa6E-7qGirZm202tYMp90","assetPrefix":"/diy-firestore","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>