<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>DIY Firestore: <!-- -->Getting Started</title><meta name="next-head-count" content="3"/><link rel="preload" href="/diy-firestore/_next/static/css/66a0bbf2b9cf8488.css" as="style"/><link rel="stylesheet" href="/diy-firestore/_next/static/css/66a0bbf2b9cf8488.css" data-n-g=""/><link rel="preload" href="/diy-firestore/_next/static/css/ada12569730546bb.css" as="style"/><link rel="stylesheet" href="/diy-firestore/_next/static/css/ada12569730546bb.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/diy-firestore/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/diy-firestore/_next/static/chunks/webpack-df07c8c7f42d9fe8.js" defer=""></script><script src="/diy-firestore/_next/static/chunks/framework-85abacfba991a725.js" defer=""></script><script src="/diy-firestore/_next/static/chunks/main-319ff90b30ad4d29.js" defer=""></script><script src="/diy-firestore/_next/static/chunks/pages/_app-4394fb9185eabbc7.js" defer=""></script><script src="/diy-firestore/_next/static/chunks/9f529197-49e08325ab61b49d.js" defer=""></script><script src="/diy-firestore/_next/static/chunks/97-3f87bb423d54673c.js" defer=""></script><script src="/diy-firestore/_next/static/chunks/pages/posts/%5B%5B...slug%5D%5D-0bd81a0611356f07.js" defer=""></script><script src="/diy-firestore/_next/static/o-RxRcpQaaFNhYAx32Ehv/_buildManifest.js" defer=""></script><script src="/diy-firestore/_next/static/o-RxRcpQaaFNhYAx32Ehv/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="post_content__PPM5L"><nav class="post_nav__Q8sPv"><div class="post_homeLink__F688Z"><a href="/diy-firestore/">DIY Firestore</a></div></nav><main id="main-content"><article class="post_article__Q7gsU"><h1>Getting Started</h1>
<p><strong><em>How hard could it be?</em></strong></p>
<!-- -->
<p>Firestore is pretty cool. It is a NoSQL document database that lets you store
arbitrary documents in hierarchical collections, but it also lets you perform
queries and transactions similar to those you can make with a SQL database. On
top of that, Firestore allows frontend clients to connect directly to the
database and listen for changes that affect their queries, removing the need for
the user to implement stateful websockets or poll their servers for updates. In
this regard Firestore acts not only as a database, but also as a full fledged
system for managing data synchronization between your frontend and backend.</p>
<p>In this article we will take a look at how we could implement many of the
features that Firestore provides using standard open source and cloud
technologies.</p>
<p>But first,</p>
<h2>Why would we do this?</h2>
<p>It&#x27;s a fair question. Firestore is flush with features, so why would we go
through the effort of implementing a system that does pretty much the same
thing?</p>
<h3>It&#x27;s fun!</h3>
<p>Just had to get this out of the way. I am mostly just writing this for fun.
Firestore is a pretty cool system to investigate, so I hope you enjoy reading
about how I go about implementing it!</p>
<h3>You&#x27;re not on gcp</h3>
<p>Firestore is a GCP product and does not have a direct equivalent in other cloud
providers. If all of your apps and services are based in AWS for example, you
might not be able to readily use technologies in GCP. Or maybe your division
built multiple frontend apps around Firebase then your company made the
unilateral decision to move to AWS, and now you are stuck figuring out what to
do.</p>
<h3>You need more configurability</h3>
<p>Firestore is a generic product and does not provide many options for configuration.</p>
<p>All database resources are managed for you and you pay per read and write. Only paying for your individual
reads and writes is convenient when you are starting a project, but it limits the amount of
configurability you can have. A cost model where you pay for the underlying
infrastructure supporting your database rather than paying per read and write removes these limitations.</p>
<p>At the end of this series, I will show some examples
of how we could customize our database to suit our needs in a way that Firestore might not.</p>
<h3>You&#x27;re cloud costs are too high</h3>
<p>Firestore is designed to be highly scalable and have a low barrier to entry, but
it is also quite expensive. This likely doesn&#x27;t matter when you are just
starting a company and want to get up and running quickly, but as your traffic
grows, Firestore&#x27;s high price per read and write could become a problem.</p>
<p>Over the course of this series, we will see how Firestore&#x27;s default features incur a lot
of overhead whether you are using them or not. Firestore lets you turn some of
these features off, but many of them are on no matter what. Running a customized
version of Firestore would give you the transparency needed to understand what
operations are expensive and allow you to turn off expensive features that you
don&#x27;t need.</p>
<h2>#Goals</h2>
<p>The purpose of this article is to demonstrate how we could implement a data
management system like Firestore using technologies that are either open source
or available with most cloud providers.</p>
<p>I will focus on designing this system so that we get our desired features with
acceptable time and space complexity, but I will not focus on optimizing our
solution. Instead, I want to convey how we could overcome the key technical
hurdles that get in the way of making a database like Firestore, and to that
end, will opt for clarity over performance. Likewise, code samples I include
will be correct, but won&#x27;t be production ready. I will assume that all inputs
are validated and well formatted and the general approach to error handling
will be to throw a runtime error. Let chaos reign!</p>
<p>I also want to note in advance that I do not have any inside knowledge of how
Firestore is implemented. This series is just me taking a stab at how I would
build a similar product.</p>
<h2>Next up</h2>
<p>With all that out of the way, let&#x27;s define the scope of what we will be covering in this series.</p></article></main><footer class="post_footer__wtu2H"><div><a href="/diy-firestore/posts/defining-requirements/">Defining Our Requirements<!-- --> â†’</a></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\n/*image of wrench bucket -\u003e fire*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    strong: \"strong\",\n    em: \"em\",\n    h2: \"h2\",\n    h3: \"h3\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Getting Started\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: _jsx(_components.em, {\n          children: \"How hard could it be?\"\n        })\n      })\n    }), \"\\n\", \"\\n\", _jsx(_components.p, {\n      children: \"Firestore is pretty cool. It is a NoSQL document database that lets you store\\narbitrary documents in hierarchical collections, but it also lets you perform\\nqueries and transactions similar to those you can make with a SQL database. On\\ntop of that, Firestore allows frontend clients to connect directly to the\\ndatabase and listen for changes that affect their queries, removing the need for\\nthe user to implement stateful websockets or poll their servers for updates. In\\nthis regard Firestore acts not only as a database, but also as a full fledged\\nsystem for managing data synchronization between your frontend and backend.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In this article we will take a look at how we could implement many of the\\nfeatures that Firestore provides using standard open source and cloud\\ntechnologies.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But first,\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Why would we do this?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It's a fair question. Firestore is flush with features, so why would we go\\nthrough the effort of implementing a system that does pretty much the same\\nthing?\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"It's fun!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Just had to get this out of the way. I am mostly just writing this for fun.\\nFirestore is a pretty cool system to investigate, so I hope you enjoy reading\\nabout how I go about implementing it!\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"You're not on gcp\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Firestore is a GCP product and does not have a direct equivalent in other cloud\\nproviders. If all of your apps and services are based in AWS for example, you\\nmight not be able to readily use technologies in GCP. Or maybe your division\\nbuilt multiple frontend apps around Firebase then your company made the\\nunilateral decision to move to AWS, and now you are stuck figuring out what to\\ndo.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"You need more configurability\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Firestore is a generic product and does not provide many options for configuration.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"All database resources are managed for you and you pay per read and write. Only paying for your individual\\nreads and writes is convenient when you are starting a project, but it limits the amount of\\nconfigurability you can have. A cost model where you pay for the underlying\\ninfrastructure supporting your database rather than paying per read and write removes these limitations.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"At the end of this series, I will show some examples\\nof how we could customize our database to suit our needs in a way that Firestore might not.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"You're cloud costs are too high\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Firestore is designed to be highly scalable and have a low barrier to entry, but\\nit is also quite expensive. This likely doesn't matter when you are just\\nstarting a company and want to get up and running quickly, but as your traffic\\ngrows, Firestore's high price per read and write could become a problem.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Over the course of this series, we will see how Firestore's default features incur a lot\\nof overhead whether you are using them or not. Firestore lets you turn some of\\nthese features off, but many of them are on no matter what. Running a customized\\nversion of Firestore would give you the transparency needed to understand what\\noperations are expensive and allow you to turn off expensive features that you\\ndon't need.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"#Goals\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The purpose of this article is to demonstrate how we could implement a data\\nmanagement system like Firestore using technologies that are either open source\\nor available with most cloud providers.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I will focus on designing this system so that we get our desired features with\\nacceptable time and space complexity, but I will not focus on optimizing our\\nsolution. Instead, I want to convey how we could overcome the key technical\\nhurdles that get in the way of making a database like Firestore, and to that\\nend, will opt for clarity over performance. Likewise, code samples I include\\nwill be correct, but won't be production ready. I will assume that all inputs\\nare validated and well formatted and the general approach to error handling\\nwill be to throw a runtime error. Let chaos reign!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I also want to note in advance that I do not have any inside knowledge of how\\nFirestore is implemented. This series is just me taking a stab at how I would\\nbuild a similar product.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Next up\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"With all that out of the way, let's define the scope of what we will be covering in this series.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"title":"Getting Started","index":1,"previousPost":null,"nextPost":{"title":"Defining Our Requirements","index":2,"slug":"defining-requirements"}},"__N_SSG":true},"page":"/posts/[[...slug]]","query":{"slug":["intro"]},"buildId":"o-RxRcpQaaFNhYAx32Ehv","assetPrefix":"/diy-firestore","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>