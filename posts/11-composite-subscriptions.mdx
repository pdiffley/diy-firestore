### Composite Query Subscriptions

More complicated

We benefit from knowing the field group in advance

For a particular field group, there are still a wide variety of queries we need
to support

Notably, for the primary field we support any combination of 5 operators (<,
<=, >, >=, =, and !=)

Supporting any combination of these operators makes it difficult to make a
concise schema that can desribe all of the queries users are subscribed to

Fortunately, we can use the characteristics of these operators to reduce this
complexity significantly.

To understand this let's imagine putting our field_values on a number line (of
sorts)

<number line with min and max>

All the way to the left we have our designated minimum value, and all the way to
the right, we have the maximum value.

Now let's imagine that we place two less than constraints on the field_value in
our query

x < a

x < b

<number line with two less than constraints>

It's immediately apparent that we have some redundancy here. regardless of how
many "less than" constraints we put on our field value, only the one with the
lowest parameter value is going to matter, so we know that our queries only need
to support on constraint of a "less than" variety.

We still have two types of less than operator though, "less than" and "less than
or equal to". Notice that the less than operation can also be expressed as a
combination of the "<=" operation and a "!=" operation.

That is "x < a" is equivalent to "x <= a AND x != a". So anytime we receive a
query with a "<" operator we can convert is to be written in terms of the "<="
operator and the "!=" operator. As far as our schema is concerned we can pretend
like the "<" operator does not exist.

The same logic applies to "greater than" constraints as well, so we know that
for any query we only need to support one "<=" and one ">=" operator.

We can also express the "=" operation as a combination of "<=" and ">="
operators. That is "x = a" is equivalent to "x <= a AND x >=a".

Unfortunately, there is not much we can do about the "!=" operator. A user can
specify as many "!=" constraints as they want and we can't reduce them.

All of this together means that we can take any set of constraints on our
primary field and reduce those constraints to a single "<=" condition, a single
">=" condition, and a set of "!=" conditions. This is a set of constraints that
we can reasonably represent through a single schema.

Secondary Constraints

The secondary constraints are much easier to manage. For any secondary field in
a field group, only constraints with the "=" operator are allowed, so this does
not add much complexity.

Subscription tables

With our reduced constraint set we can now make a pair of tables to describe all
of the subscribed queries for our composite field group

```postgresql
CREATE TABLE composite_included_table_d8b8c614b73546daa1d85531dc412ef6(
  min_age           field_value,
  max_age           field_value,
  city              field_value,
  user_name         field_value,
  zipcode           field_value
  subscription_id   TEXT,
  PRIMARY KEY (subscription_id)
);
```

```postgresql
CREATE TABLE composite_excluded_table_d8b8c614b73546daa1d85531dc412ef6 (
  excluded_age      field_value,
  subscription_id   TEXT,
  PRIMARY KEY (excluded_age, subscription_id)
);
```

The first "included" table has one row for every subscription that specifies the
"<=" and ">=" constraint on the primary field and the "=" constraints on the
secondary fields.

The second "excluded" table has a row for every "!=" constraint on the primary
field.

We can then get all of the matching subscriptions with a query like

```
select distinct subscription_id from {} where excluded_{} = $1
```

The actual code for creating that query and getting the matching subscriptions
gets pretty knarly, but we can reduce that complexity as well with the power of
an elipses

```rust
fn get_matching_composite_query_subscriptions(
  transaction: &mut Transaction,
  document: &Document,
  composite_groups: &[CompositeFieldGroup],
) -> Vec<String> {
  let mut matching_subscriptions: Vec<String> = vec![];
  // ...
  matching_subscriptions
}
```

Amazing what you can do with three little dots right?

If you really want to see sample code for that function, you can find it in the
github project <link>. For now, we will just pretend like we implemented it, add
it to our create and delete functions, and call it a day.

```rust
fn create_document(
  transaction: &mut Transaction,
  collection_parent_path: &str,
  collection_id: &str,
  document_id: &str,
  update_id: &str,
  document: &Document,
  composite_groups: &[CompositeFieldGroup],
) {
  let mut encoded_document: Vec<u8> = vec![];
  document.encode(&mut encoded_document).unwrap();

  add_document_to_documents_table(transaction, collection_parent_path, collection_id, document_id, update_id, &encoded_document);
  add_document_to_simple_query_table(transaction, collection_parent_path, collection_id, document_id, document);
  add_document_to_composite_query_tables(transaction, collection_parent_path, collection_id, document_id, document, composite_groups);

  let mut matching_subscriptions = vec![];
  matching_subscriptions.extend(get_matching_basic_subscription_ids(transaction, collection_parent_path, collection_id, document_id).into_iter());
  matching_subscriptions.extend(get_matching_simple_query_subscriptions(transaction, collection_parent_path, collection_id, document).into_iter());
  matching_subscriptions.extend(get_matching_composite_query_subscriptions(transaction, document, composite_groups).into_iter());

  // Todo: send update to matching subscriptions
}
```

```rust
pub fn delete_document(
  transaction: &mut Transaction,
  collection_parent_path: &str,
  collection_id: &str,
  document_id: &str,
  composite_groups: &[CompositeFieldGroup],
) {
  if let Some(document) = get_document(transaction, collection_parent_path, collection_id, document_id) {
    delete_document_from_documents_table(transaction, collection_parent_path, collection_id, document_id);
    delete_document_from_simple_query_table(transaction, collection_parent_path, collection_id, document_id);
    delete_document_from_composite_query_tables(transaction, collection_parent_path, collection_id, document_id, composite_groups);

    let mut matching_subscriptions = vec![];
    matching_subscriptions.extend(get_matching_basic_subscription_ids(transaction, collection_parent_path, collection_id, document_id).into_iter());
    matching_subscriptions.extend(get_matching_simple_query_subscriptions(transaction, collection_parent_path, collection_id, &document).into_iter());
    matching_subscriptions.extend(get_matching_composite_query_subscriptions(transaction, &document, composite_groups).into_iter());

    // Todo: send update to matching subscriptions
  }
}
```

### Next up

We have now written the code we need to monitor updates to any subscriptions to
our database, but we haven't writtent the code to subscribe to a query in the
first place, or listen for updates from a client. We'll to that next.
